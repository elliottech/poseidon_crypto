package ecgfp5

// ECgFp5 base field is quintic extension of Goldilocks, which can
// be generated by gnark-crypto, but it lacks some functionality.

import (
	"math/big"

	config "github.com/consensys/gnark-crypto/field/generator/config"
	f "github.com/consensys/gnark-crypto/field/goldilocks"
)

var (
	FP5_D = 5

	FP5_ZERO = config.Element{
		*new(big.Int),
		*new(big.Int),
		*new(big.Int),
		*new(big.Int),
		*new(big.Int),
	}
	FP5_ONE = config.Element{
		*new(big.Int).SetUint64(1),
		*new(big.Int),
		*new(big.Int),
		*new(big.Int),
		*new(big.Int),
	}
	FP5_TWO = config.Element{
		*new(big.Int).SetUint64(2),
		*new(big.Int),
		*new(big.Int),
		*new(big.Int),
		*new(big.Int),
	}

	FP5_W        = f.NewElement(3)
	FP5_DTH_ROOT = f.NewElement(1041288259238279555)
)

// tested
func Fp5IsZero(e config.Element) bool {
	return e[0].Sign() == 0 && e[1].Sign() == 0 && e[2].Sign() == 0 && e[3].Sign() == 0 && e[4].Sign() == 0
}

func Fp5DeepCopy(e config.Element) config.Element {
	return config.Element{
		*new(big.Int).Set(&e[0]),
		*new(big.Int).Set(&e[1]),
		*new(big.Int).Set(&e[2]),
		*new(big.Int).Set(&e[3]),
		*new(big.Int).Set(&e[4]),
	}
}

// tested
func Fp5ToFArray(e config.Element) [5]*f.Element {
	e1 := f.NewElement(e[0].Uint64())
	e2 := f.NewElement(e[1].Uint64())
	e3 := f.NewElement(e[2].Uint64())
	e4 := f.NewElement(e[3].Uint64())
	e5 := f.NewElement(e[4].Uint64())
	return [5]*f.Element{&e1, &e2, &e3, &e4, &e5}
}

// tested
func FArrayToFp5(e [5]*f.Element) config.Element {
	return config.Element{
		*new(big.Int).SetUint64(e[0].Uint64()),
		*new(big.Int).SetUint64(e[1].Uint64()),
		*new(big.Int).SetUint64(e[2].Uint64()),
		*new(big.Int).SetUint64(e[3].Uint64()),
		*new(big.Int).SetUint64(e[4].Uint64()),
	}
}

// tested
func Fp5Add(a, b config.Element) config.Element {
	aCopy := Fp5ToFArray(a)
	bCopy := Fp5ToFArray(b)

	_0 := FAdd(aCopy[0], bCopy[0])
	_1 := FAdd(aCopy[1], bCopy[1])
	_2 := FAdd(aCopy[2], bCopy[2])
	_3 := FAdd(aCopy[3], bCopy[3])
	_4 := FAdd(aCopy[4], bCopy[4])

	res := FArrayToFp5([5]*f.Element{&_0, &_1, &_2, &_3, &_4})
	return res
}

// tested
func Fp5Sub(a, b config.Element) config.Element {
	aCopy := Fp5ToFArray(a)
	bCopy := Fp5ToFArray(b)

	_0 := FSub(aCopy[0], bCopy[0])
	_1 := FSub(aCopy[1], bCopy[1])
	_2 := FSub(aCopy[2], bCopy[2])
	_3 := FSub(aCopy[3], bCopy[3])
	_4 := FSub(aCopy[4], bCopy[4])

	res := FArrayToFp5([5]*f.Element{&_0, &_1, &_2, &_3, &_4})
	return res
}

// tested
func Fp5Mul(a, b config.Element) config.Element {
	// let Self([a0, a1, a2, a3, a4]) = self;
	aCopy := Fp5ToFArray(a)
	a0 := aCopy[0]
	a1 := aCopy[1]
	a2 := aCopy[2]
	a3 := aCopy[3]
	a4 := aCopy[4]
	// let Self([b0, b1, b2, b3, b4]) = rhs;
	bCopy := Fp5ToFArray(b)
	b0 := bCopy[0]
	b1 := bCopy[1]
	b2 := bCopy[2]
	b3 := bCopy[3]
	b4 := bCopy[4]
	// let w = <Self as OEF<5>>::W;
	w := FDeepCopy(&FP5_W)
	// let c0 = a0 * b0 + w * (a1 * b4 + a2 * b3 + a3 * b2 + a4 * b1);
	a0b0 := FMul(a0, b0)
	a1b4 := FMul(a1, b4)
	a2b3 := FMul(a2, b3)
	a3b2 := FMul(a3, b2)
	a4b1 := FMul(a4, b1)
	added := FAdd(&a1b4, &a2b3, &a3b2, &a4b1)
	muld := FMul(&w, &added)
	c0 := FAdd(&a0b0, &muld)
	// let c1 = a0 * b1 + a1 * b0 + w * (a2 * b4 + a3 * b3 + a4 * b2);
	a0b1 := FMul(a0, b1)
	a1b0 := FMul(a1, b0)
	a2b4 := FMul(a2, b4)
	a3b3 := FMul(a3, b3)
	a4b2 := FMul(a4, b2)
	added = FAdd(&a2b4, &a3b3, &a4b2)
	muld = FMul(&w, &added)
	c1 := FAdd(&a0b1, &a1b0, &muld)
	// let c2 = a0 * b2 + a1 * b1 + a2 * b0 + w * (a3 * b4 + a4 * b3);
	a0b2 := FMul(a0, b2)
	a1b1 := FMul(a1, b1)
	a2b0 := FMul(a2, b0)
	a3b4 := FMul(a3, b4)
	a4b3 := FMul(a4, b3)
	added = FAdd(&a3b4, &a4b3)
	muld = FMul(&w, &added)
	c2 := FAdd(&a0b2, &a1b1, &a2b0, &muld)
	// let c3 = a0 * b3 + a1 * b2 + a2 * b1 + a3 * b0 + w * a4 * b4;
	a0b3 := FMul(a0, b3)
	a1b2 := FMul(a1, b2)
	a2b1 := FMul(a2, b1)
	a3b0 := FMul(a3, b0)
	a4b4 := FMul(a4, b4)
	muld = FMul(&w, &a4b4)
	c3 := FAdd(&a0b3, &a1b2, &a2b1, &a3b0, &muld)
	// let c4 = a0 * b4 + a1 * b3 + a2 * b2 + a3 * b1 + a4 * b0;
	a0b4 := FMul(a0, b4)
	a1b3 := FMul(a1, b3)
	a2b2 := FMul(a2, b2)
	a3b1 := FMul(a3, b1)
	a4b0 := FMul(a4, b0)
	c4 := FAdd(&a0b4, &a1b3, &a2b2, &a3b1, &a4b0)

	return FArrayToFp5([5]*f.Element{&c0, &c1, &c2, &c3, &c4})
}

// 33% Optimized square
// tested
func Fp5Square(a config.Element) config.Element {
	// let Self([a0, a1, a2, a3, a4]) = *self;
	aCopy := Fp5ToFArray(a)
	a0 := aCopy[0]
	a1 := aCopy[1]
	a2 := aCopy[2]
	a3 := aCopy[3]
	a4 := aCopy[4]
	// let w = <Self as OEF<5>>::W;
	w := FDeepCopy(&FP5_W)
	// let double_w = <Self as OEF<5>>::W.double();
	double_w := FAdd(&w, &w)

	// let c0 = a0.square() + double_w * (a1 * a4 + a2 * a3);
	a0s := FMul(a0, a0)
	a1a4 := FMul(a1, a4)
	a2a3 := FMul(a2, a3)
	added := FAdd(&a1a4, &a2a3)
	muld := FMul(&double_w, &added)
	c0 := FAdd(&a0s, &muld)
	// let double_a0 = a0.double();
	a0Double := FAdd(a0, a0)
	// let c1 = double_a0 * a1 + double_w * a2 * a4 + w * a3 * a3;
	a0Doublea1 := FMul(&a0Double, a1)
	a2a4DoubleW := FMul(a2, a4, &double_w)
	a3a3w := FMul(a3, a3, &w)
	c1 := FAdd(&a0Doublea1, &a2a4DoubleW, &a3a3w)
	// let c2 = double_a0 * a2 + a1 * a1 + double_w * a4 * a3;
	a0Doublea2 := FMul(&a0Double, a2)
	a1Square := FMul(a1, a1)
	a4a3DoubleW := FMul(a4, a3, &double_w)
	c2 := FAdd(&a0Doublea2, &a1Square, &a4a3DoubleW)
	// let double_a1 = a1.double();
	a1Double := FAdd(a1, a1)
	// let c3 = double_a0 * a3 + double_a1 * a2 + w * a4 * a4;
	a0Doublea3 := FMul(&a0Double, a3)
	a1Doublea2 := FMul(&a1Double, a2)
	a4SquareW := FMul(a4, a4, &w)
	c3 := FAdd(&a0Doublea3, &a1Doublea2, &a4SquareW)
	// let c4 = double_a0 * a4 + double_a1 * a3 + a2 * a2;
	a0Doublea4 := FMul(&a0Double, a4)
	a1Doublea3 := FMul(&a1Double, a3)
	a2Square := FMul(a2, a2)
	c4 := FAdd(&a0Doublea4, &a1Doublea3, &a2Square)

	return FArrayToFp5([5]*f.Element{&c0, &c1, &c2, &c3, &c4})
}

func Fp5ScalarMul(a config.Element, scalar *f.Element) config.Element {
	arr := Fp5ToFArray(a)
	for i := 0; i < len(arr); i++ {
		arr[i].Mul(arr[i], scalar)
	}
	return FArrayToFp5(arr)
}

func Fp5Double(a config.Element) config.Element {
	return Fp5Add(a, a)
}

func Fp5FromUint64(a uint64) config.Element {
	return config.Element{*new(big.Int).SetUint64(a), *new(big.Int), *new(big.Int), *new(big.Int), *new(big.Int)}
}

func Fp5NegOne() config.Element {
	fNegOne := FNegOne()
	return config.Element{
		*new(big.Int).SetUint64(fNegOne[0]),
		*new(big.Int),
		*new(big.Int),
		*new(big.Int),
		*new(big.Int),
	}
}

// tested
func Fp5InverseOrZero(a config.Element) config.Element {
	if Fp5IsZero(a) {
		return FP5_ZERO
	}

	// Writing 'a' for self:
	d := Fp5Frobenius(a)                       // d = a^p
	e := Fp5Mul(d, Fp5Frobenius(d))            // e = a^(p + p^2)
	f := Fp5Mul(e, Fp5RepeatedFrobenius(e, 2)) // f = a^(p + p^2 + p^3 + p^4)

	// g = a^r is in the base field, so only compute that
	// coefficient rather than the full product. The equation is
	// extracted from Mul::mul(...) below.
	aCopy := Fp5ToFArray(a)
	a0 := aCopy[0]
	a1 := aCopy[1]
	a2 := aCopy[2]
	a3 := aCopy[3]
	a4 := aCopy[4]
	fCopy := Fp5ToFArray(f)
	b0 := fCopy[0]
	b1 := fCopy[1]
	b2 := fCopy[2]
	b3 := fCopy[3]
	b4 := fCopy[4]
	// g = a0 * b0 + <Self as OEF<5>>::W * (a1 * b4 + a2 * b3 + a3 * b2 + a4 * b1);
	a0b0 := FMul(a0, b0)
	a1b4 := FMul(a1, b4)
	a2b3 := FMul(a2, b3)
	a3b2 := FMul(a3, b2)
	a4b1 := FMul(a4, b1)
	added := FAdd(&a1b4, &a2b3, &a3b2, &a4b1)
	muld := FMul(&FP5_W, &added)
	g := FAdd(&a0b0, &muld)

	return Fp5ScalarMul(f, g.Inverse(&g))
}

// FrobeniusField automorphisms: x -> x^p, where p is the order of BaseField.
// tested
func Fp5Frobenius(x config.Element) config.Element {
	return Fp5RepeatedFrobenius(x, 1)
}

// Repeated Frobenius automorphisms: x -> x^(p^count).
//
// Follows precomputation suggestion in Section 11.3.3 of the
// Handbook of Elliptic and Hyperelliptic Curve Cryptography.
// tested
func Fp5RepeatedFrobenius(x config.Element, count int) config.Element {
	if count == 0 {
		return x
	} else if count >= FP5_D {
		// x |-> x^(p^D) is the identity, so x^(p^count) == x^(p^(count % D))
		return Fp5RepeatedFrobenius(x, count%FP5_D)
	}

	arr := Fp5ToFArray(x)

	// z0 = DTH_ROOT^count = W^(k * count) where k = floor((p^D-1)/D)
	z0 := FDeepCopy(&FP5_DTH_ROOT)
	for i := 1; i < count; i++ {
		z0 = FMul(&FP5_DTH_ROOT, &z0)
	}

	res := Fp5ToFArray(FP5_ZERO)
	for i, z := range FPowers(&z0, FP5_D) {
		muld := FMul(arr[i], &z)
		res[i] = &muld
	}

	res2 := FArrayToFp5(res)
	return res2
}
