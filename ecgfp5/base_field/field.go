package ecgfp5

// ECgFp5 base field is quintic extension of Goldilocks, which can
// be generated by gnark-crypto, but it lacks some functionality.

import (
	"math/big"

	config "github.com/consensys/gnark-crypto/field/generator/config"
	g "github.com/elliottech/poseidon_crypto/field/goldilocks"
)

var (
	FP5_D = 5

	FP5_ZERO = config.Element{
		*new(big.Int),
		*new(big.Int),
		*new(big.Int),
		*new(big.Int),
		*new(big.Int),
	}
	FP5_ONE = config.Element{
		*new(big.Int).SetUint64(1),
		*new(big.Int),
		*new(big.Int),
		*new(big.Int),
		*new(big.Int),
	}
	FP5_TWO = config.Element{
		*new(big.Int).SetUint64(2),
		*new(big.Int),
		*new(big.Int),
		*new(big.Int),
		*new(big.Int),
	}

	FP5_W        = g.FromUint64(3)
	FP5_DTH_ROOT = g.FromUint64(1041288259238279555)
)

func Fp5Sample() config.Element {
	arr := g.RandArray(5)
	return FArrayToFp5([5]*g.Element{&arr[0], &arr[1], &arr[2], &arr[3], &arr[4]})
}

func Fp5Equals(a, b config.Element) bool {
	return a[0].Cmp(&b[0]) == 0 && a[1].Cmp(&b[1]) == 0 && a[2].Cmp(&b[2]) == 0 && a[3].Cmp(&b[3]) == 0 && a[4].Cmp(&b[4]) == 0
}

func Fp5IsZero(e config.Element) bool {
	return e[0].Sign() == 0 && e[1].Sign() == 0 && e[2].Sign() == 0 && e[3].Sign() == 0 && e[4].Sign() == 0
}

func Fp5DeepCopy(e config.Element) config.Element {
	return config.Element{
		*new(big.Int).Set(&e[0]),
		*new(big.Int).Set(&e[1]),
		*new(big.Int).Set(&e[2]),
		*new(big.Int).Set(&e[3]),
		*new(big.Int).Set(&e[4]),
	}
}

func Fp5FromF(elem g.Element) config.Element {
	one := new(big.Int)
	elem.BigInt(one)
	return config.Element{
		*one,
		*new(big.Int),
		*new(big.Int),
		*new(big.Int),
		*new(big.Int),
	}
}

func Fp5ToFArray(e config.Element) [5]*g.Element {
	e1 := g.FromUint64(e[0].Uint64())
	e2 := g.FromUint64(e[1].Uint64())
	e3 := g.FromUint64(e[2].Uint64())
	e4 := g.FromUint64(e[3].Uint64())
	e5 := g.FromUint64(e[4].Uint64())
	return [5]*g.Element{&e1, &e2, &e3, &e4, &e5}
}

func FArrayToFp5(e [5]*g.Element) config.Element {
	return config.Element{
		*new(big.Int).SetUint64(e[0].Uint64()),
		*new(big.Int).SetUint64(e[1].Uint64()),
		*new(big.Int).SetUint64(e[2].Uint64()),
		*new(big.Int).SetUint64(e[3].Uint64()),
		*new(big.Int).SetUint64(e[4].Uint64()),
	}
}

func Uint64ArrayToFp5(e1, e2, e3, e4, e5 uint64) config.Element {
	return config.Element{
		*new(big.Int).SetUint64(e1),
		*new(big.Int).SetUint64(e2),
		*new(big.Int).SetUint64(e3),
		*new(big.Int).SetUint64(e4),
		*new(big.Int).SetUint64(e5),
	}
}

func Fp5Neg(e config.Element) config.Element {
	eCopy := Fp5ToFArray(e)
	_0 := g.Neg(*eCopy[0])
	_1 := g.Neg(*eCopy[1])
	_2 := g.Neg(*eCopy[2])
	_3 := g.Neg(*eCopy[3])
	_4 := g.Neg(*eCopy[4])
	return FArrayToFp5([5]*g.Element{&_0, &_1, &_2, &_3, &_4})
}

func Fp5Add(a, b config.Element) config.Element {
	aCopy := Fp5ToFArray(a)
	bCopy := Fp5ToFArray(b)

	_0 := g.FAdd(*aCopy[0], *bCopy[0])
	_1 := g.FAdd(*aCopy[1], *bCopy[1])
	_2 := g.FAdd(*aCopy[2], *bCopy[2])
	_3 := g.FAdd(*aCopy[3], *bCopy[3])
	_4 := g.FAdd(*aCopy[4], *bCopy[4])

	res := FArrayToFp5([5]*g.Element{&_0, &_1, &_2, &_3, &_4})
	return res
}

func Fp5Sub(a, b config.Element) config.Element {
	aCopy := Fp5ToFArray(a)
	bCopy := Fp5ToFArray(b)

	_0 := g.FSub(aCopy[0], bCopy[0])
	_1 := g.FSub(aCopy[1], bCopy[1])
	_2 := g.FSub(aCopy[2], bCopy[2])
	_3 := g.FSub(aCopy[3], bCopy[3])
	_4 := g.FSub(aCopy[4], bCopy[4])

	res := FArrayToFp5([5]*g.Element{&_0, &_1, &_2, &_3, &_4})
	return res
}

func Fp5Mul(a, b config.Element) config.Element {
	aCopy := Fp5ToFArray(a)
	a0 := aCopy[0]
	a1 := aCopy[1]
	a2 := aCopy[2]
	a3 := aCopy[3]
	a4 := aCopy[4]
	bCopy := Fp5ToFArray(b)
	b0 := bCopy[0]
	b1 := bCopy[1]
	b2 := bCopy[2]
	b3 := bCopy[3]
	b4 := bCopy[4]
	w := g.FDeepCopy(&FP5_W)
	a0b0 := g.FMul(a0, b0)
	a1b4 := g.FMul(a1, b4)
	a2b3 := g.FMul(a2, b3)
	a3b2 := g.FMul(a3, b2)
	a4b1 := g.FMul(a4, b1)
	added := g.FAdd(a1b4, a2b3, a3b2, a4b1)
	muld := g.FMul(&w, &added)
	c0 := g.FAdd(a0b0, muld)
	a0b1 := g.FMul(a0, b1)
	a1b0 := g.FMul(a1, b0)
	a2b4 := g.FMul(a2, b4)
	a3b3 := g.FMul(a3, b3)
	a4b2 := g.FMul(a4, b2)
	added = g.FAdd(a2b4, a3b3, a4b2)
	muld = g.FMul(&w, &added)
	c1 := g.FAdd(a0b1, a1b0, muld)
	a0b2 := g.FMul(a0, b2)
	a1b1 := g.FMul(a1, b1)
	a2b0 := g.FMul(a2, b0)
	a3b4 := g.FMul(a3, b4)
	a4b3 := g.FMul(a4, b3)
	added = g.FAdd(a3b4, a4b3)
	muld = g.FMul(&w, &added)
	c2 := g.FAdd(a0b2, a1b1, a2b0, muld)
	a0b3 := g.FMul(a0, b3)
	a1b2 := g.FMul(a1, b2)
	a2b1 := g.FMul(a2, b1)
	a3b0 := g.FMul(a3, b0)
	a4b4 := g.FMul(a4, b4)
	muld = g.FMul(&w, &a4b4)
	c3 := g.FAdd(a0b3, a1b2, a2b1, a3b0, muld)
	a0b4 := g.FMul(a0, b4)
	a1b3 := g.FMul(a1, b3)
	a2b2 := g.FMul(a2, b2)
	a3b1 := g.FMul(a3, b1)
	a4b0 := g.FMul(a4, b0)
	c4 := g.FAdd(a0b4, a1b3, a2b2, a3b1, a4b0)

	return FArrayToFp5([5]*g.Element{&c0, &c1, &c2, &c3, &c4})
}

func Fp5Div(a, b config.Element) config.Element {
	bInv := Fp5InverseOrZero(b)
	if Fp5IsZero(bInv) {
		panic("division by zero")
	}
	return Fp5Mul(a, bInv)
}

func Fp5ExpPowerOf2(x config.Element, power int) config.Element {
	res := Fp5DeepCopy(x)
	for i := 0; i < power; i++ {
		res = Fp5Square(res)
	}
	return res
}

// 33% Optimized square
func Fp5Square(a config.Element) config.Element {
	aCopy := Fp5ToFArray(a)
	a0 := aCopy[0]
	a1 := aCopy[1]
	a2 := aCopy[2]
	a3 := aCopy[3]
	a4 := aCopy[4]
	w := g.FDeepCopy(&FP5_W)
	double_w := g.FAdd(w, w)

	a0s := g.FMul(a0, a0)
	a1a4 := g.FMul(a1, a4)
	a2a3 := g.FMul(a2, a3)
	added := g.FAdd(a1a4, a2a3)
	muld := g.FMul(&double_w, &added)
	c0 := g.FAdd(a0s, muld)
	a0Double := g.FAdd(*a0, *a0)
	a0Doublea1 := g.FMul(&a0Double, a1)
	a2a4DoubleW := g.FMul(a2, a4, &double_w)
	a3a3w := g.FMul(a3, a3, &w)
	c1 := g.FAdd(a0Doublea1, a2a4DoubleW, a3a3w)
	a0Doublea2 := g.FMul(&a0Double, a2)
	a1Square := g.FMul(a1, a1)
	a4a3DoubleW := g.FMul(a4, a3, &double_w)
	c2 := g.FAdd(a0Doublea2, a1Square, a4a3DoubleW)
	a1Double := g.FAdd(*a1, *a1)
	a0Doublea3 := g.FMul(&a0Double, a3)
	a1Doublea2 := g.FMul(&a1Double, a2)
	a4SquareW := g.FMul(a4, a4, &w)
	c3 := g.FAdd(a0Doublea3, a1Doublea2, a4SquareW)
	a0Doublea4 := g.FMul(&a0Double, a4)
	a1Doublea3 := g.FMul(&a1Double, a3)
	a2Square := g.FMul(a2, a2)
	c4 := g.FAdd(a0Doublea4, a1Doublea3, a2Square)

	return FArrayToFp5([5]*g.Element{&c0, &c1, &c2, &c3, &c4})
}

func Fp5Triple(a config.Element) config.Element {
	three := g.FromUint64(3)
	aCopy := Fp5ToFArray(a)

	e0 := g.FMul(aCopy[0], &three)
	e1 := g.FMul(aCopy[1], &three)
	e2 := g.FMul(aCopy[2], &three)
	e3 := g.FMul(aCopy[3], &three)
	e4 := g.FMul(aCopy[4], &three)

	return FArrayToFp5([5]*g.Element{&e0, &e1, &e2, &e3, &e4})
}

// returns `sqrt(x)` if `x` is a square in the field, and `Nil` otherwise
// basically copied from here: https://github.com/pornin/ecquintic_ext/blob/ce059c6d1e1662db437aecbf3db6bb67fe63c716/python/ecGFp5.py#L879
func Fp5Sqrt(x config.Element) (config.Element, bool) {
	v := Fp5ExpPowerOf2(x, 31)
	d := Fp5Mul(Fp5Mul(x, Fp5ExpPowerOf2(v, 32)), Fp5InverseOrZero(v))
	e := Fp5Frobenius(Fp5Mul(d, Fp5RepeatedFrobenius(d, 2)))
	_f := Fp5Square(e)

	xArr := Fp5ToFArray(x)
	x0 := xArr[0]
	x1 := xArr[1]
	x2 := xArr[2]
	x3 := xArr[3]
	x4 := xArr[4]

	fArr := Fp5ToFArray(_f)
	f0 := fArr[0]
	f1 := fArr[1]
	f2 := fArr[2]
	f3 := fArr[3]
	f4 := fArr[4]

	x1f4 := g.FMul(x1, f4)
	x2f3 := g.FMul(x2, f3)
	x3f2 := g.FMul(x3, f2)
	x4f1 := g.FMul(x4, f1)
	added := g.FAdd(x1f4, x2f3, x3f2, x4f1)
	three := g.FromUint64(3)
	muld := g.FMul(&three, &added)
	x0f0 := g.FMul(x0, f0)
	_g := g.FAdd(x0f0, muld)
	s := g.FSqrt(&_g)
	if s == nil {
		return nil, false
	}

	eInv := Fp5InverseOrZero(e)
	sFp5 := Fp5FromF(*s)

	return Fp5Mul(sFp5, eInv), true
}

// Fp5Sgn0 returns true or false indicating a notion of "sign" for quintic_ext.
// This is used to canonicalize the square root.
// This is an implementation of the function sgn0 from the IRTF's hash-to-curve document
// https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-07#name-the-sgn0-function
func Fp5Sgn0(x config.Element) bool {
	sign := false
	zero := true
	for _, limb := range x {
		sign_i := (limb.Uint64() & 1) == 0
		zero_i := limb.Sign() == 0
		sign = sign || (zero && sign_i)
		zero = zero && zero_i
	}
	return sign
}

// returns the "canonical" square root of x, if it exists
// the "canonical" square root is the one such that `sgn0(sqrt(x)) == true`
func Fp5CanonicalSqrt(x config.Element) (config.Element, bool) {
	sqrtX, exists := Fp5Sqrt(x)
	if !exists {
		return nil, false
	}

	if Fp5Sgn0(sqrtX) {
		return Fp5Neg(sqrtX), true
	}
	return sqrtX, true
}

func Fp5ScalarMul(a config.Element, scalar *g.Element) config.Element {
	arr := Fp5ToFArray(a)
	for i := 0; i < len(arr); i++ {
		arr[i].Mul(arr[i], scalar)
	}
	return FArrayToFp5(arr)
}

func Fp5Double(a config.Element) config.Element {
	return Fp5Add(a, a)
}

func Fp5FromUint64(a uint64) config.Element {
	return config.Element{*new(big.Int).SetUint64(a), *new(big.Int), *new(big.Int), *new(big.Int), *new(big.Int)}
}

func Fp5NegOne() config.Element {
	negOne := g.FNegOne()
	return config.Element{
		*new(big.Int).SetUint64(negOne[0]),
		*new(big.Int),
		*new(big.Int),
		*new(big.Int),
		*new(big.Int),
	}
}

func Fp5InverseOrZero(a config.Element) config.Element {
	if Fp5IsZero(a) {
		return FP5_ZERO
	}

	// Writing 'a' for self:
	d := Fp5Frobenius(a)                       // d = a^p
	e := Fp5Mul(d, Fp5Frobenius(d))            // e = a^(p + p^2)
	f := Fp5Mul(e, Fp5RepeatedFrobenius(e, 2)) // f = a^(p + p^2 + p^3 + p^4)

	// g = a^r is in the base field, so only compute that
	// coefficient rather than the full product. The equation is
	// extracted from Mul::mul(...) below.
	aCopy := Fp5ToFArray(a)
	a0 := aCopy[0]
	a1 := aCopy[1]
	a2 := aCopy[2]
	a3 := aCopy[3]
	a4 := aCopy[4]
	fCopy := Fp5ToFArray(f)
	b0 := fCopy[0]
	b1 := fCopy[1]
	b2 := fCopy[2]
	b3 := fCopy[3]
	b4 := fCopy[4]
	// g = a0 * b0 + <Self as OEF<5>>::W * (a1 * b4 + a2 * b3 + a3 * b2 + a4 * b1);
	a0b0 := g.FMul(a0, b0)
	a1b4 := g.FMul(a1, b4)
	a2b3 := g.FMul(a2, b3)
	a3b2 := g.FMul(a3, b2)
	a4b1 := g.FMul(a4, b1)
	added := g.FAdd(a1b4, a2b3, a3b2, a4b1)
	muld := g.FMul(&FP5_W, &added)
	g := g.FAdd(a0b0, muld)

	return Fp5ScalarMul(f, g.Inverse(&g))
}

// FrobeniusField automorphisms: x -> x^p, where p is the order of BaseField.
func Fp5Frobenius(x config.Element) config.Element {
	return Fp5RepeatedFrobenius(x, 1)
}

// Repeated Frobenius automorphisms: x -> x^(p^count).
//
// Follows precomputation suggestion in Section 11.3.3 of the
// Handbook of Elliptic and Hyperelliptic Curve Cryptography.
func Fp5RepeatedFrobenius(x config.Element, count int) config.Element {
	if count == 0 {
		return x
	} else if count >= FP5_D {
		// x |-> x^(p^D) is the identity, so x^(p^count) == x^(p^(count % D))
		return Fp5RepeatedFrobenius(x, count%FP5_D)
	}

	arr := Fp5ToFArray(x)

	// z0 = DTH_ROOT^count = W^(k * count) where k = floor((p^D-1)/D)
	z0 := g.FDeepCopy(&FP5_DTH_ROOT)
	for i := 1; i < count; i++ {
		z0 = g.FMul(&FP5_DTH_ROOT, &z0)
	}

	res := Fp5ToFArray(FP5_ZERO)
	for i, z := range g.FPowers(&z0, FP5_D) {
		muld := g.FMul(arr[i], &z)
		res[i] = &muld
	}

	res2 := FArrayToFp5(res)
	return res2
}

func Fp5Legendre(x config.Element) g.Element {
	frob1 := Fp5Frobenius(x)
	frob2 := Fp5Frobenius(frob1)

	frob1TimesFrob2 := Fp5Mul(frob1, frob2)
	frob2Frob1TimesFrob2 := Fp5RepeatedFrobenius(frob1TimesFrob2, 2)

	xrExt := Fp5Mul(Fp5Mul(x, frob1TimesFrob2), frob2Frob1TimesFrob2)
	xr := Fp5ToFArray(xrExt)[0]

	xr31 := xr.Exp(*xr, new(big.Int).SetUint64(1<<31))
	xr31Copy := g.FDeepCopy(xr31)
	xr63 := xr31Copy.Exp(*xr31, new(big.Int).SetUint64(1<<32))

	// only way `xr_31` can be zero is if `xr` is zero, in which case `self` is zero,
	// in which case we want to return zero.
	xr31InvOrZero := g.FromUint64(0)
	xr31InvOrZero = *xr31InvOrZero.Inverse(xr31)

	return g.FMul(xr63, &xr31InvOrZero)
}
